# Two-Three Tree

> 以下描述摘自Robert Sedgewick和Kevin Wayne的《算法（第4版）》

一棵**2-3查找树**或为一棵空树，或由以下结点组成：

*   2- 结点，含有一个键（及其对应的值）和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。
*   3- 结点，含有两个键（及其对应的值）和三条链接，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。

一棵**完美平衡**的2-3查找树中的所有空链接到根结点的距离都应该是相同的。

## Search

2-3树的查找算法可以看作BST的查找算法的一般化。

## Insertion

向2-3树中插入一个新结点时，我们先对树做一次未命中的查找，然后把新结点挂在树的底部。分为若干种情况：

*   若未命中的查找结束于一个2-结点，只需把这个2-结点替换为一个3-结点，将要插入的键保存在其中即可。

<!---->

    插入K：
            M               M
          /   \           /   \
       (E,J)   R  ->   (E,J)    R
      /   |  \        /   | \
    (A,C) H   L    (A,C)  H (K,L)

*   若未命中的查找结束3-结点，且结点所在的树只有当前结点，我们先把键存入该结点中，使之成为一个4-结点，然后将4-结点分解为3个2-结点组成的2-3树。

<!---->

    插入S :
     (A,E) ->  (A,E,S) ->       E
     / | \     / / \ \        /   \
                             A     S
                            / \   / \

*   若未命中的查找结束于一个父结点为2-结点的3-结点，我们先把键存入该结点，然后将中健移至父结点。

<!---->

    向树中插入Z：
          |                      |                     |
          R                      R                   (R,X)
        /   \        ->        /   \       ->       /  | \
       P   (S,X)              p   (S,X,Z)          p   S   Z
      / \  / | \             / \  / / \ \         / \ / \ / \ 

*   若未命中的查找结束于父结点为3-结点的3-结点，我们一直向上不断分解临时的4-结点并将中键插入更高层的结点。

在一棵大小为N的2-3树中，查找和插入操作访问的结点必然不超过`lg N`个。